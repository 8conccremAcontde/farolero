#+TITLE:Log Analyzer
#+AUTHOR:Joshua Suskalo
#+EMAIL:joshua@suskalo.org
#+LANGUAGE: en
#+OPTIONS: toc:nil
#+PROPERTY: header-args+ :noweb no-export :mkdirp yes :exports code :dir log-analyzer
#+STARTUP: hidestars indent

This project is a basic introduction to farolero, showing how to use the macros,
what the development process feels like, and how conditions and restarts reduce
the amount of code that needs to be written.

* Motivation & Project Setup
Log files often need to be inspected and analyzed to gain insights about
programs, how they fail, how often certain events occur, etc. This program will
read log files from a directory, parse them using a standard format, and
aggregate statistics about them.

To get started, we need a deps.edn file to start our project.

#+BEGIN_SRC clojure :tangle log-analyzer/deps.edn
  {:paths ["src"]
   :deps {org.clojure/clojure {:mvn/version "1.10.3"}
          org.suskalo/farolero {:mvn/version "1.1.1"}}}
#+END_SRC

All this does is bring in Clojure and farolero.

The project will be split up into three components, the log parser, the
analyzer, and the cli. At the end of the project we'll be able to parse logs in
multiple formats from multiple files and gather statistics about the frequency
of certain types of messages, as well as report errors to the user.

* Parsing Logs
:PROPERTIES:
:header-args:clojure+: :tangle log-analyzer/src/log_analyzer/parse.clj
:END:

In order to parse a log entry, we first need to know what the entry is going to
look like. A basic format like the one that follows is what we'll be parsing for
now.

=2021-05-21T21:46:30.321411Z [main] DEBUG some.namespace - some text=

This format consists of a date, a thread name between square brackets, the
logging level, the namespace the message was logged from, and the message.

To start with we'll require the ~farolero.core~ namespace and refer the macros
which will be used the most, along with a few other namespaces.

#+BEGIN_SRC clojure
  (ns log-analyzer.parse
    (:require
     [clojure.string :as str]
     [farolero.core :as far :refer [restart-case handler-case handler-bind]])
    (:import
     (java.time LocalDateTime)
     (java.time.format DateTimeFormatter)))
#+END_SRC

#+RESULTS:

Now that we have a namespace defined, we can make a regex which will match it.

#+BEGIN_SRC clojure
  (def log-line-regex #"^(\S+) +\[(.*?)\] +(\S+) +(\S+) +- +(.*)$")
#+END_SRC

#+RESULTS:
: #'log-analyzer.parse/log-line-regex

This regex looks a little complex, but it's quite simple in what it does. It
just checks for a sequence of non-whitespace text to match the date, some text
inside square brackets for the thread name, and so on.

With this regex, we can now make a very basic log parsing function.

#+BEGIN_SRC clojure :tangle no
  (defn parse-log-line
    [s]
    (when-let [[date thread level ns message] (next (re-matches log-line-regex s))]
      (try
        {:date (LocalDateTime/parse date DateTimeFormatter/ISO_DATE_TIME)
         :thread thread
         :level (keyword (str/lower-case level))
         :ns (symbol ns)
         :message message}
        (catch Exception _))))
#+END_SRC

#+RESULTS:
: #'log-analyzer.parse/parse-log-line

This function parses an individual log line into a map.

#+BEGIN_SRC clojure :tangle no :exports both
  (parse-log-line "2021-05-21T21:46:30.321411Z [main] DEBUG some.namespace - some text")
  (parse-log-line "Some random invalid log line")
#+END_SRC

#+RESULTS:
| {:date #object(java.time.LocalDateTime 0x3c051b9c "2021-05-21T21:46:30.321411")  :thread "main"  :level :debug  :ns some.namespace  :message "some text"} |
| nil                                                                                                                                                       |

There is one problem with this implementation however: if it encounters a log
line that doesn't fit the regex or with an invalid date format, it always
returns ~nil~, regardless of what the problem was. Initially this doesn't seem
like a problem, and it's how a lot of code is written, but this means that in
circumstances where you would like to know about the errors, and potentially do
something about them, you have no option but to write another function, or
change callers of this function to handle errors.

In cases where there are few functions and a shallow stack, this may not be a
large burden, but if it was buried many layers deep behind many functions you
don't want to rewrite, this may prove a significant burden.

Instead, let us define these functions like this:

#+BEGIN_SRC clojure
  (defn parse-log-line
    [s]
    (restart-case
        (if-let [[date thread level ns message] (next (re-matches log-line-regex s))]
          (try
            {:date (LocalDateTime/parse date DateTimeFormatter/ISO_DATE_TIME)
             :thread thread
             :level (keyword (str/lower-case level))
             :ns (symbol ns)
             :message message}
            (catch Exception e
              (far/error ::invalid-log-entry
                         :log-line s
                         :cause e)))
          (far/error ::invalid-log-entry
                     :log-line s
                     :cause ::failed-regex-match))
      (::far/continue [])
      (::far/use-value [v] v)))

  (defn parse-log-file
    [lines]
    (keep parse-log-line lines))
#+END_SRC

#+RESULTS:
: #'log-analyzer.parse/parse-log-line

This change gives us a lot of power. Let's walk through this. Instead of using a
~when-let~ and simply returning ~nil~ when a log line fails to match, and
catching exceptions and returning ~nil~ on date formatting parsers, we call
~farolero.core/error~ and pass it the keyword ~::invalid-log-entry~. You can
think of this almost like throwing an exception of a custom type. It will look
up the stack to try to find something that "catches" (or in farolero parlance,
"handles") the error.

#+BEGIN_SRC clojure :tangle no :exports both
  (parse-log-line "2021-05-21T21:46:30.321411Z [main] DEBUG some.namespace - some text")
  (parse-log-line "Some random invalid log line")
#+END_SRC

#+RESULTS:
| {:date #object[java.time.LocalDateTime 0x7b79b9c "2021-05-21T21:46:30.321411"], :thread "main", :level :debug, :ns some.namespace, :message "some text"}                                              |
| #clojure.lang.ExceptionInfo {:message "Unhandled Condition", :data {:condition ::invalid-log-entry, :args '(:log-line "Some random invalid log line" :cause :log-analyzer.parse/failed-regex-match)}} |

If we wanted to catch the condition, we can use ~handler-case~.

#+BEGIN_SRC clojure :tangle no :exports both :results pp
  (handler-case (parse-log-line "Some random invalid log line")
    (::invalid-log-entry [_ & {:keys [log-line]}]
      log-line))
#+END_SRC

#+RESULTS:
: "Some random invalid log line"
:

Where this differs from exceptions however is in what you can do when you
respond to the error. In this case, the call is wrapped in a ~restart-case~,
binding two restarts, ~::far/continue~, and ~::far/use-value~. If we use
~handler-bind~, we can register a handler that will invoke one of those restarts.

For example, if we use the ~::far/continue~ restart, which we can invoke with
~farolero.core/continue~, it will return nil from parse-log-line, which will in
turn be removed by ~keep~.

#+BEGIN_SRC clojure :tangle no :exports both
  (handler-bind [::invalid-log-entry (fn [_ & {:keys [log-line]}]
                                       (far/continue))]
    (parse-log-file
     ["Some random invalid log line"
      "2021-05-21T21:46:30.321411Z [main] DEBUG some.namespace - some text"]))
#+END_SRC

#+RESULTS:
: '(nil (:date #object(java.time.LocalDateTime 0x27fb80cf "2021-05-21T21:46:30.321411")  :thread "main"  :level :debug  :ns some.namespace  :message "some text"))

If we invoke the ~::far/use-value~ restart, we can substitute our own value for
the log entry.

#+BEGIN_SRC clojure :tangle no :exports both
  (handler-bind [::invalid-log-entry (fn [_ & _]
                                       (far/use-value :invalid-entry))]
    (parse-log-line "Some random invalid log line"))
#+END_SRC

#+RESULTS:
: :invalid-entry

One of the uses this could have is to allow multiple log formats to be parsed.
In the old implementation, if we wanted to support multiple log formats, we'd
have to change the regex, and the construction of the map, basically requiring
an entirely new function. With this way of handling logs, we can extend the
existing behavior to add new valid log entries. This may be useful if for
example we have our application's process sending its logs to stdout, the same
place where a process monitor is also sinking its logs.

#+BEGIN_SRC clojure :tangle no :exports both :results pp
  (def alternate-log-format #"\[(\S+)\] (\S+) - (.*)")

  (defn alt-middleware
    [f]
    (fn [& args]
      (handler-bind [::invalid-log-entry
                     (fn [_ & {:keys [log-line]}]
                       (when-let [[level ns message] (next (re-matches alternate-log-format log-line))]
                         (far/use-value {:level (keyword (str/lower-case level))
                                         :ns (symbol ns)
                                         :message message})))]
                    (apply f args))))

  (handler-bind [::invalid-log-entry (fn [_ & _] (far/continue))]
    ((alt-middleware (comp doall parse-log-file))
     ["Some random invalid log line"
      "2021-05-21T21:46:30.321411Z [main] DEBUG some.namespace - some text"
      "[DEBUG] other.namespace - More text"]))
#+END_SRC

#+RESULTS:
: ({:date
:   #object[java.time.LocalDateTime 0xc5cee50 "2021-05-21T21:46:30.321411"],
:   :thread "main",
:   :level :debug,
:   :ns some.namespace,
:   :message "some text"}
:  {:level :debug, :ns other.namespace, :message "More text"})
: 

This ~alt-middleware~ function takes the function it wants to wrap, in this case
an eager-ized ~parse-log-file~, and then returns a function that calls it in the
context of a handler for ~::invalid-log-entry~ that will attempt to parse it
using a second log format. Notice however that if it fails to parse the log
line, it simply returns normally instead of invoking a restart. This is
intentional. If a handler returns normally without invoking a restart, then it
has decided not to handle the condition, and handlers further up the stack will
be used, in this case the one which calls the ~far/continue~ restart.

As a footnote here, farolero includes a macro for converting exceptions to
conditions, ~wrap-exceptions~, which catches all exceptions and signals them as
conditions:

#+BEGIN_SRC clojure :tangle no :exports both
  (handler-case (far/wrap-exceptions
                  (throw (ex-info "An error!" {})))
    (Exception [e]
      (ex-message e)))
#+END_SRC

#+RESULTS:
: An error!

* TODO Aggregating Statistics
* TODO Creating a CLI
